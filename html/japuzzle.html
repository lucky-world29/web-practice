<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Photon Grid ‚Äî Hard</title>
<style>
  :root{--bg:#0f1724;--panel:#0b1220;--accent:#82e0aa;--muted:#94a3b8}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#e6eef8;display:flex;align-items:flex-start;justify-content:center;height:100vh;padding:28px;box-sizing:border-box}
  .ui{width:920px;display:flex;gap:20px}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:18px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
  .left{width:640px}
  .right{width:240px}
  h1{margin:0 0 8px;font-size:18px}
  p.small{margin:4px 0 14px;color:var(--muted);font-size:13px}
  #board{background:linear-gradient(180deg, rgba(0,0,0,0.07), rgba(255,255,255,0.02));border-radius:8px;padding:10px;display:grid;place-items:center}
  svg{display:block}
  .controls{display:flex;gap:8px;margin-top:12px}
  button{background:var(--panel);color:inherit;border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}
  button.primary{background:linear-gradient(180deg,#0ea5a1,#0284c7);color:white;border:none;box-shadow:0 6px 18px rgba(2,132,199,0.18)}
  .stat{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;margin-bottom:10px}
  .hint{font-size:13px;color:#ffdd99}
  footer{font-size:12px;color:var(--muted);margin-top:14px}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .legend .item{display:flex;gap:6px;align-items:center;font-size:13px;color:var(--muted)}
  .tile-icon{width:22px;height:22px;border-radius:4px;display:grid;place-items:center;font-weight:700}
</style>
</head>
<body>
  <div class="ui">
    <div class="panel left">
      <h1>Photon Grid ‚Äî Hard</h1>
      <p class="small">Rotate mirrors to guide the laser from the emitter to hit all targets. Click mirror tiles to rotate (90¬∞). Press <strong>FIRE</strong> to trace the beam. Hard puzzle preset: limited moves, blockers, tricky reflections.</p>

      <div id="board" class="panel">
        <!-- SVG grid will be injected -->
      </div>

      <div class="controls">
        <button id="fireBtn" class="primary">FIRE</button>
        <button id="resetBtn">Reset</button>
        <button id="hintBtn">Hint (reveals 1 tile)</button>
        <button id="shuffleBtn">Shuffle</button>
        <div style="margin-left:auto" class="stat">Moves: <span id="moves">0</span> / <span id="maxMoves">0</span></div>
      </div>

      <footer>Controls: Click mirrors to rotate. Fire to test. Hard level ‚Äî think ahead!</footer>
    </div>

    <div class="panel right">
      <h1>Legend</h1>
      <div class="legend">
        <div class="item"><div class="tile-icon" style="background:#022c2f">E</div> Emitter</div>
        <div class="item"><div class="tile-icon" style="background:#2b3b4a">‚ñ†</div> Blocker</div>
        <div class="item"><div class="tile-icon" style="background:transparent;border:1px dashed rgba(255,255,255,0.06)">/ \</div> Mirror (click to rotate)</div>
        <div class="item"><div class="tile-icon" style="background:#1c334f">‚óè</div> Target</div>
      </div>

      <div style="margin-top:14px">
        <div class="stat">Status: <div id="status" style="display:inline-block;margin-left:8px;color:#ffcc99">Not fired</div></div>
        <div class="stat">Targets hit: <strong id="hitCount">0</strong> / <strong id="targetCount">0</strong></div>
        <div class="stat hint" id="hintBox" style="display:none"></div>
      </div>
    </div>
  </div>

<script>
/* Photon Grid ‚Äî Single-file game
   Grid coordinates: (r,c) top-left (0,0)
   Tile types:
     0 = empty
     1 = mirror (orientation 0..3) 0: '/', 1: '\', 2: '/', 3: '\' (rotations)
     2 = blocker (solid)
     3 = emitter {dir:0-3}
     4 = target
*/

const rows=7, cols=7;
const CELL=72; // svg cell size
let grid = [];
let moves=0, maxMoves=9; // hard limit
let emitter = {r:3,c:0,dir:0}; // default emitter (left edge)
let targets=[];
let hitTargets=new Set();

const boardEl = document.getElementById('board');
const fireBtn=document.getElementById('fireBtn');
const resetBtn=document.getElementById('resetBtn');
const hintBtn=document.getElementById('hintBtn');
const shuffleBtn=document.getElementById('shuffleBtn');
const movesEl=document.getElementById('moves');
const maxMovesEl=document.getElementById('maxMoves');
const statusEl=document.getElementById('status');
const hitCountEl=document.getElementById('hitCount');
const targetCountEl=document.getElementById('targetCount');
const hintBox=document.getElementById('hintBox');

maxMovesEl.textContent = maxMoves;

function makeEmptyGrid(){
  const g = Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>({type:0,ori:0})));
  return g;
}

// Hard preset layout (designed to be challenging)
function loadHardPreset(){
  grid = makeEmptyGrid();
  // blockers
  const blockers = [
    [1,2],[1,3],[1,4],
    [2,4],[3,4],[4,4],[5,4],
    [5,2],[5,3]
  ];
  blockers.forEach(([r,c])=> grid[r][c]={type:2});

  // mirrors: list [r,c,ori] (ori: 0 => '/', 1 => '\', 2 => '/', 3 => '\')
  const mirrors = [
    [0,1,1],[0,2,0],[0,3,1],
    [2,1,0],[2,2,1],[3,2,0],
    [4,1,1],[4,2,0],[4,3,1],
    [6,3,0],[6,4,1],[3,6,1]
  ];
  mirrors.forEach(([r,c,ori])=> grid[r][c]={type:1,ori});

  // emitter at left middle pointing right
  emitter={r:3,c:0,dir:0}; // dir: 0=right,1=down,2=left,3=up
  grid[emitter.r][emitter.c]={type:3,dir:emitter.dir};

  // targets (must hit all)
  targets = [[0,6],[2,6],[6,6]]; // three targets on right column
  targets.forEach(([r,c])=> grid[r][c]={type:4,hit:false});

  moves=0;
  hitTargets=new Set();
  updateUI();
}

function render(){
  const width = cols*CELL, height=rows*CELL;
  boardEl.innerHTML = '';
  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('width', width+20);
  svg.setAttribute('height', height+20);
  svg.setAttribute('viewBox', `0 0 ${width+20} ${height+20}`);
  svg.style.maxWidth='100%';
  boardEl.appendChild(svg);

  // background
  const bg = document.createElementNS(svgNS,'rect');
  bg.setAttribute('x',0); bg.setAttribute('y',0);
  bg.setAttribute('width', width+20); bg.setAttribute('height', height+20);
  bg.setAttribute('rx',8); bg.setAttribute('fill','none');
  svg.appendChild(bg);

  // draw grid cells
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x = 10 + c*CELL, y=10 + r*CELL;
      const cellGroup = document.createElementNS(svgNS,'g');
      cellGroup.setAttribute('transform',`translate(${x},${y})`);
      cellGroup.dataset.r=r;
      cellGroup.dataset.c=c;

      // cell background
      const rect=document.createElementNS(svgNS,'rect');
      rect.setAttribute('x',0); rect.setAttribute('y',0);
      rect.setAttribute('width',CELL-4); rect.setAttribute('height',CELL-4);
      rect.setAttribute('rx',8);
      rect.setAttribute('fill','rgba(255,255,255,0.01)');
      rect.setAttribute('stroke','rgba(255,255,255,0.03)');
      cellGroup.appendChild(rect);

      const tile = grid[r][c];

      if(tile.type===2){ // blocker
        const b=document.createElementNS(svgNS,'rect');
        b.setAttribute('x',10); b.setAttribute('y',10);
        b.setAttribute('width',CELL-24); b.setAttribute('height',CELL-24);
        b.setAttribute('rx',6); b.setAttribute('fill','#233042'); b.setAttribute('opacity',0.95);
        cellGroup.appendChild(b);
      } else if(tile.type===1){ // mirror
        const gMir = document.createElementNS(svgNS,'g');
        const mid = (CELL-4)/2;
        gMir.setAttribute('transform',`translate(${mid},${mid}) rotate(${tile.ori*90}) translate(${-mid},${-mid})`);
        const path = document.createElementNS(svgNS,'path');
        path.setAttribute('d', `M ${10} ${CELL-14} L ${CELL-14} ${10}`); // slash-like
        path.setAttribute('stroke','#a7f3d0'); path.setAttribute('stroke-width','6'); path.setAttribute('stroke-linecap','round');
        path.setAttribute('fill','none'); path.setAttribute('opacity',0.95);
        gMir.appendChild(path);
        cellGroup.appendChild(gMir);

        // clickable rotate
        cellGroup.style.cursor='pointer';
        cellGroup.addEventListener('click', e => {
          rotateMirror(r,c);
        });
      } else if(tile.type===3){ // emitter
        const cx = (CELL-4)/2, cy = (CELL-4)/2;
        const emitterG = document.createElementNS(svgNS,'g');
        // body circle
        const circ=document.createElementNS(svgNS,'circle');
        circ.setAttribute('cx',cx); circ.setAttribute('cy',cy);
        circ.setAttribute('r',14); circ.setAttribute('fill','#04f5a2'); emitterG.appendChild(circ);
        // arrow
        const arrow = document.createElementNS(svgNS,'polygon');
        const a = tile.dir;
        let points;
        if(a===0) points = `${cx-6},${cy-10} ${cx-6},${cy+10} ${cx+12},${cy}`;
        if(a===1) points = `${cx-10},${cy-6} ${cx+10},${cy-6} ${cx},${cy+12}`;
        if(a===2) points = `${cx+6},${cy-10} ${cx+6},${cy+10} ${cx-12},${cy}`;
        if(a===3) points = `${cx-10},${cy+6} ${cx+10},${cy+6} ${cx},${cy-12}`;
        arrow.setAttribute('points',points);
        arrow.setAttribute('fill','#052827');
        emitterG.appendChild(arrow);
        cellGroup.appendChild(emitterG);
      } else if(tile.type===4){ // target
        const cx = (CELL-4)/2, cy=(CELL-4)/2;
        const circle=document.createElementNS(svgNS,'circle');
        circle.setAttribute('cx',cx); circle.setAttribute('cy',cy);
        circle.setAttribute('r',12);
        const hit = tile.hit ? '#ffd166' : '#1d3557';
        circle.setAttribute('fill',hit);
        circle.setAttribute('stroke',tile.hit ? '#ffd166' : '#94a3b8');
        circle.setAttribute('stroke-width',2);
        cellGroup.appendChild(circle);
        // small dot to show target
        const dot=document.createElementNS(svgNS,'circle');
        dot.setAttribute('cx',cx); dot.setAttribute('cy',cy); dot.setAttribute('r',4); dot.setAttribute('fill','#e9f5ff');
        cellGroup.appendChild(dot);
      }

      svg.appendChild(cellGroup);
    }
  }
}

// rotate mirror (click)
function rotateMirror(r,c){
  const t = grid[r][c];
  if(!t || t.type!==1) return;
  t.ori = (t.ori+1) % 4;
  moves++;
  movesEl.textContent=moves;
  hintBox.style.display='none';
  render();
  statusEl.textContent='Not fired';
}

// simulate laser raytrace; returns list of path segments and hit targets
function simulate(showDraw=true){
  // reset targets hit flag
  targets.forEach(([tr,tc])=> grid[tr][tc].hit=false);
  hitTargets.clear();
  const pathSegments = []; // {x1,y1,x2,y2}
  const visited = new Set(); // to avoid infinite loops store state r,c,dir
  let r = emitter.r, c = emitter.c, dir = emitter.dir;
  // start point center of emitter cell
  let px = c + 0.5, py = r + 0.5;

  const dirVec = [[1,0],[0,1],[-1,0],[0,-1]];

  // trace step by step cell-to-cell
  while(true){
    // move to next cell in direction
    const [dr,dc] = dirVec[dir];
    let nr = r + dr, nc = c + dc;
    const x1 = px, y1 = py;
    if(nr<0 || nr>=rows || nc<0 || nc>=cols){
      // out of bounds ‚Äî ray exits
      const x2 = nc < 0 ? 0 : (nc >= cols ? cols : nc) + 0.0;
      const y2 = nr < 0 ? 0 : (nr >= rows ? rows : nr) + 0.0;
      pathSegments.push({x1,y1,x2,y2});
      break;
    }
    // ray crosses cell boundary to center of next cell
    const x2 = nc + 0.5, y2 = nr + 0.5;
    pathSegments.push({x1,y1,x2,y2});
    // update
    r = nr; c = nc; px = x2; py = y2;

    // check for blockers
    const tile = grid[r][c];
    if(tile.type===2){
      // stops at blocker
      break;
    }
    // check for target
    if(tile.type===4){
      tile.hit = true;
      hitTargets.add(`${r},${c}`);
    }

    // reflect on mirror
    if(tile.type===1){
      // mirror orientation: use tile.ori parity to determine slash/backslash
      const isSlash = tile.ori % 2 === 0; // 0 or 2 => slash-like
      // reflection rules for cardinal dirs:
      // slash '/' : right(0)->up(3), up(3)->right(0), left(2)->down(1), down(1)->left(2)
      // backslash '\' : right(0)->down(1), down(1)->right(0), left(2)->up(3), up(3)->left(2)
      if(isSlash){
        if(dir===0) dir=3;
        else if(dir===3) dir=0;
        else if(dir===2) dir=1;
        else if(dir===1) dir=2;
      } else {
        if(dir===0) dir=1;
        else if(dir===1) dir=0;
        else if(dir===2) dir=3;
        else if(dir===3) dir=2;
      }
    }

    // detect loops
    const state = `${r},${c},${dir}`;
    if(visited.has(state)){
      // stuck in loop -> break
      break;
    }
    visited.add(state);
  }

  // draw beam overlay
  drawWithPath(pathSegments);

  hitCountEl.textContent = hitTargets.size;
  targetCountEl.textContent = targets.length;
  return hitTargets.size === targets.length;
}

function drawWithPath(segments){
  // overlay beam on svg by drawing lines scaled to cell pixels
  // Remove previous beam group if any
  const svg = boardEl.querySelector('svg');
  const prev = svg.querySelector('#beamGroup');
  if(prev) prev.remove();
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  g.setAttribute('id','beamGroup');
  g.setAttribute('opacity','0.95');
  segments.forEach(seg=>{
    const L = document.createElementNS('http://www.w3.org/2000/svg','line');
    const scale = CELL;
    const offset = 10;
    L.setAttribute('x1', offset + seg.x1*scale);
    L.setAttribute('y1', offset + seg.y1*scale);
    L.setAttribute('x2', offset + seg.x2*scale);
    L.setAttribute('y2', offset + seg.y2*scale);
    L.setAttribute('stroke','#ffd166');
    L.setAttribute('stroke-width',6);
    L.setAttribute('stroke-linecap','round');
    g.appendChild(L);
    // small glow
    const glow = document.createElementNS('http://www.w3.org/2000/svg','line');
    glow.setAttribute('x1', offset + seg.x1*scale);
    glow.setAttribute('y1', offset + seg.y1*scale);
    glow.setAttribute('x2', offset + seg.x2*scale);
    glow.setAttribute('y2', offset + seg.y2*scale);
    glow.setAttribute('stroke','#fff1');
    glow.setAttribute('stroke-width',2);
    g.appendChild(glow);
  });
  svg.appendChild(g);
}

function updateUI(){
  movesEl.textContent = moves;
  hitCountEl.textContent = hitTargets.size;
  targetCountEl.textContent = targets.length;
  statusEl.textContent = 'Not fired';
  hintBox.style.display='none';
  render();
}

// Reset to preset
resetBtn.addEventListener('click', ()=>{
  loadHardPreset();
  render();
});

// Fire button
fireBtn.addEventListener('click', ()=>{
  if(moves > maxMoves){
    statusEl.textContent = 'Move limit exceeded ‚Äî reset or shuffle.';
    return;
  }
  const solved = simulate();
  statusEl.textContent = solved ? 'Solved! You hit all targets üéâ' : 'Not solved ‚Äî try again';
  if(solved){
    // celebratory style
    statusEl.style.color = '#a6f0c1';
  } else {
    statusEl.style.color = '#ffcc99';
  }
});

// hint button: simple heuristic - find first mirror that when rotated increases number of hits
hintBtn.addEventListener('click', ()=>{
  // brute-force: test rotating each mirror by +1 and see if hits increase
  let best=null, bestHits= -1;
  // copy grid state
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
    const t = grid[r][c];
    if(!t || t.type!==1) continue;
    // try rotated state
    t.ori = (t.ori+1)%4;
    // simulate quickly (without drawing): we'll call simulate() which draws, so we revert after
    const prevHits = new Set(hitTargets);
    const prevGridCopy = JSON.parse(JSON.stringify(grid));
    const hitAll = simulate(false);
    const hits = hitTargets.size;
    if(hits > bestHits){
      bestHits=hits; best=[r,c];
    }
    // restore grid exactly
    for(let rr=0;rr<rows;rr++){
      for(let cc=0;cc<cols;cc++){
        grid[rr][cc].type = prevGridCopy[rr][cc].type;
        if(grid[rr][cc].type===1) grid[rr][cc].ori = prevGridCopy[rr][cc].ori;
        if(grid[rr][cc].type===3) grid[rr][cc].dir = prevGridCopy[rr][cc].dir;
        if(grid[rr][cc].type===4) grid[rr][cc].hit = prevGridCopy[rr][cc].hit;
      }
    }
    hitTargets = new Set([...prevHits]);
  }
  if(best){
    hintBox.style.display='block';
    hintBox.textContent = `Hint: try rotating the mirror at row ${best[0]+1}, col ${best[1]+1} (1-indexed).`;
    // show visual marker: flash that cell
    flashCell(best[0],best[1]);
  } else {
    hintBox.style.display='block';
    hintBox.textContent = 'No helpful hint found.';
  }
  // consume a move for hint to keep game hard
  moves++;
  movesEl.textContent = moves;
});

function flashCell(r,c){
  const svg = boardEl.querySelector('svg');
  // overlay a circle that fades
  const cx = 10 + c*CELL + (CELL-4)/2;
  const cy = 10 + r*CELL + (CELL-4)/2;
  const circ=document.createElementNS('http://www.w3.org/2000/svg','circle');
  circ.setAttribute('cx',cx); circ.setAttribute('cy',cy); circ.setAttribute('r',14);
  circ.setAttribute('fill','#ffd166'); circ.setAttribute('opacity','0.8'); circ.setAttribute('id','hintFlash');
  svg.appendChild(circ);
  setTimeout(()=>{circ.remove()},1200);
}

// shuffle small randomization but keep puzzle hard
shuffleBtn.addEventListener('click', ()=>{
  // rotate every mirror randomly a bit
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
    const t = grid[r][c];
    if(t && t.type===1){
      t.ori = (t.ori + Math.floor(Math.random()*4))%4;
    }
  }
  moves=0;
  hitTargets=new Set();
  updateUI();
});

// initial load
loadHardPreset();
render();

// convenience: keyboard F to fire
window.addEventListener('keydown', e=>{
  if(e.key.toLowerCase()==='f') fireBtn.click();
});
</script>
</body>
</html>
